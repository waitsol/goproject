// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.3
// source: msg.proto

package pb3

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CSBuyOrSellReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IsBuy         *bool                  `protobuf:"varint,1,opt,name=is_buy,json=isBuy,proto3,oneof" json:"is_buy,omitempty"`
	Code          *string                `protobuf:"bytes,2,opt,name=code,proto3,oneof" json:"code,omitempty"`
	Money         *string                `protobuf:"bytes,3,opt,name=money,proto3,oneof" json:"money,omitempty"`
	Num           *string                `protobuf:"bytes,4,opt,name=num,proto3,oneof" json:"num,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CSBuyOrSellReq) Reset() {
	*x = CSBuyOrSellReq{}
	mi := &file_msg_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CSBuyOrSellReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CSBuyOrSellReq) ProtoMessage() {}

func (x *CSBuyOrSellReq) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CSBuyOrSellReq.ProtoReflect.Descriptor instead.
func (*CSBuyOrSellReq) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{0}
}

func (x *CSBuyOrSellReq) GetIsBuy() bool {
	if x != nil && x.IsBuy != nil {
		return *x.IsBuy
	}
	return false
}

func (x *CSBuyOrSellReq) GetCode() string {
	if x != nil && x.Code != nil {
		return *x.Code
	}
	return ""
}

func (x *CSBuyOrSellReq) GetMoney() string {
	if x != nil && x.Money != nil {
		return *x.Money
	}
	return ""
}

func (x *CSBuyOrSellReq) GetNum() string {
	if x != nil && x.Num != nil {
		return *x.Num
	}
	return ""
}

type CSBuyOrSellRsp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Result        *int32                 `protobuf:"varint,1,opt,name=result,proto3,oneof" json:"result,omitempty"`
	Req           *CSBuyOrSellReq        `protobuf:"bytes,2,opt,name=req,proto3,oneof" json:"req,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CSBuyOrSellRsp) Reset() {
	*x = CSBuyOrSellRsp{}
	mi := &file_msg_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CSBuyOrSellRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CSBuyOrSellRsp) ProtoMessage() {}

func (x *CSBuyOrSellRsp) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CSBuyOrSellRsp.ProtoReflect.Descriptor instead.
func (*CSBuyOrSellRsp) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{1}
}

func (x *CSBuyOrSellRsp) GetResult() int32 {
	if x != nil && x.Result != nil {
		return *x.Result
	}
	return 0
}

func (x *CSBuyOrSellRsp) GetReq() *CSBuyOrSellReq {
	if x != nil {
		return x.Req
	}
	return nil
}

type PacketReq struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Packet:
	//
	//	*PacketReq_Bs
	Packet        isPacketReq_Packet `protobuf_oneof:"packet"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketReq) Reset() {
	*x = PacketReq{}
	mi := &file_msg_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketReq) ProtoMessage() {}

func (x *PacketReq) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketReq.ProtoReflect.Descriptor instead.
func (*PacketReq) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{2}
}

func (x *PacketReq) GetPacket() isPacketReq_Packet {
	if x != nil {
		return x.Packet
	}
	return nil
}

func (x *PacketReq) GetBs() *CSBuyOrSellReq {
	if x != nil {
		if x, ok := x.Packet.(*PacketReq_Bs); ok {
			return x.Bs
		}
	}
	return nil
}

type isPacketReq_Packet interface {
	isPacketReq_Packet()
}

type PacketReq_Bs struct {
	Bs *CSBuyOrSellReq `protobuf:"bytes,1,opt,name=bs,proto3,oneof"`
}

func (*PacketReq_Bs) isPacketReq_Packet() {}

type PacketRsp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Packet:
	//
	//	*PacketRsp_Bs
	Packet        isPacketRsp_Packet `protobuf_oneof:"packet"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PacketRsp) Reset() {
	*x = PacketRsp{}
	mi := &file_msg_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PacketRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PacketRsp) ProtoMessage() {}

func (x *PacketRsp) ProtoReflect() protoreflect.Message {
	mi := &file_msg_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PacketRsp.ProtoReflect.Descriptor instead.
func (*PacketRsp) Descriptor() ([]byte, []int) {
	return file_msg_proto_rawDescGZIP(), []int{3}
}

func (x *PacketRsp) GetPacket() isPacketRsp_Packet {
	if x != nil {
		return x.Packet
	}
	return nil
}

func (x *PacketRsp) GetBs() *CSBuyOrSellRsp {
	if x != nil {
		if x, ok := x.Packet.(*PacketRsp_Bs); ok {
			return x.Bs
		}
	}
	return nil
}

type isPacketRsp_Packet interface {
	isPacketRsp_Packet()
}

type PacketRsp_Bs struct {
	Bs *CSBuyOrSellRsp `protobuf:"bytes,1,opt,name=bs,proto3,oneof"`
}

func (*PacketRsp_Bs) isPacketRsp_Packet() {}

var File_msg_proto protoreflect.FileDescriptor

const file_msg_proto_rawDesc = "" +
	"\n" +
	"\tmsg.proto\"\x9d\x01\n" +
	"\x0eCSBuyOrSellReq\x12\x1a\n" +
	"\x06is_buy\x18\x01 \x01(\bH\x00R\x05isBuy\x88\x01\x01\x12\x17\n" +
	"\x04code\x18\x02 \x01(\tH\x01R\x04code\x88\x01\x01\x12\x19\n" +
	"\x05money\x18\x03 \x01(\tH\x02R\x05money\x88\x01\x01\x12\x15\n" +
	"\x03num\x18\x04 \x01(\tH\x03R\x03num\x88\x01\x01B\t\n" +
	"\a_is_buyB\a\n" +
	"\x05_codeB\b\n" +
	"\x06_moneyB\x06\n" +
	"\x04_num\"h\n" +
	"\x0eCSBuyOrSellRsp\x12\x1b\n" +
	"\x06result\x18\x01 \x01(\x05H\x00R\x06result\x88\x01\x01\x12&\n" +
	"\x03req\x18\x02 \x01(\v2\x0f.CSBuyOrSellReqH\x01R\x03req\x88\x01\x01B\t\n" +
	"\a_resultB\x06\n" +
	"\x04_req\"8\n" +
	"\tPacketReq\x12!\n" +
	"\x02bs\x18\x01 \x01(\v2\x0f.CSBuyOrSellReqH\x00R\x02bsB\b\n" +
	"\x06packet\"8\n" +
	"\tPacketRsp\x12!\n" +
	"\x02bs\x18\x01 \x01(\v2\x0f.CSBuyOrSellRspH\x00R\x02bsB\b\n" +
	"\x06packetB\n" +
	"Z\bmain/pb3b\x06proto3"

var (
	file_msg_proto_rawDescOnce sync.Once
	file_msg_proto_rawDescData []byte
)

func file_msg_proto_rawDescGZIP() []byte {
	file_msg_proto_rawDescOnce.Do(func() {
		file_msg_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_msg_proto_rawDesc), len(file_msg_proto_rawDesc)))
	})
	return file_msg_proto_rawDescData
}

var file_msg_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_msg_proto_goTypes = []any{
	(*CSBuyOrSellReq)(nil), // 0: CSBuyOrSellReq
	(*CSBuyOrSellRsp)(nil), // 1: CSBuyOrSellRsp
	(*PacketReq)(nil),      // 2: PacketReq
	(*PacketRsp)(nil),      // 3: PacketRsp
}
var file_msg_proto_depIdxs = []int32{
	0, // 0: CSBuyOrSellRsp.req:type_name -> CSBuyOrSellReq
	0, // 1: PacketReq.bs:type_name -> CSBuyOrSellReq
	1, // 2: PacketRsp.bs:type_name -> CSBuyOrSellRsp
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_msg_proto_init() }
func file_msg_proto_init() {
	if File_msg_proto != nil {
		return
	}
	file_msg_proto_msgTypes[0].OneofWrappers = []any{}
	file_msg_proto_msgTypes[1].OneofWrappers = []any{}
	file_msg_proto_msgTypes[2].OneofWrappers = []any{
		(*PacketReq_Bs)(nil),
	}
	file_msg_proto_msgTypes[3].OneofWrappers = []any{
		(*PacketRsp_Bs)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_msg_proto_rawDesc), len(file_msg_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_msg_proto_goTypes,
		DependencyIndexes: file_msg_proto_depIdxs,
		MessageInfos:      file_msg_proto_msgTypes,
	}.Build()
	File_msg_proto = out.File
	file_msg_proto_goTypes = nil
	file_msg_proto_depIdxs = nil
}
